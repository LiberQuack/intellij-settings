<templateSet group="Redux">
  <template name="rdxkeys" value="export enum $ENUM_NAMES$ActionKeys {&#10;    FETCH_INIT = &quot;$KEY_NAMES$_fetch_init&quot;,&#10;    FETCHED = &quot;$KEY_NAMES$_fetched&quot;,&#10;    FETCH_ERROR = &quot;$KEY_NAMES$_fetch_error&quot;,&#10;}" description="Generates redux action keys boilerplate" toReformat="true" toShortenFQNames="true">
    <variable name="ENUM_NAMES" expression="capitalize(camelCase(fileNameWithoutExtension()))" defaultValue="" alwaysStopAt="true" />
    <variable name="KEY_NAMES" expression="snakeCase(ENUM_NAMES)" defaultValue="" alwaysStopAt="false" />
    <context>
      <option name="JAVA_SCRIPT" value="true" />
      <option name="TypeScript" value="true" />
    </context>
  </template>
  <template name="rdxactions" value="import {Action, AnyAction} from &quot;redux&quot;;&#10;import {ThunkAction} from &quot;redux-thunk&quot;;&#10;&#10;export const $NAME$Actions = {&#10;&#10;    fetched($ARGUMENT_NAME$: Array&lt;any&gt;): AnyAction {&#10;        return {&#10;            type: $FETCHED_ACTION_TYPE$,&#10;            payload: $ARGUMENT_NAME$&#10;        }&#10;    },&#10;&#10;    fetchInited(): Action {&#10;        return {&#10;            type: $FETCH_INIT_ACTION_TYPE$&#10;        }&#10;    },&#10;    &#10;    fetchExceptionCaught(response, statusCode, noNetworkError): AnyAction {&#10;        return {&#10;            type: $FETCH_ERROR_ACTION_TYPE$,&#10;            payload: {&#10;                response,&#10;                statusCode,&#10;                noNetworkError,&#10;            }&#10;        }&#10;    }&#10;&#10;    fetch(filters?: any): $FETCH_RETURN_TYPE$ {&#10;        return async (dispatch, getState, extraArguments) =&gt; {&#10;            dispatch(this.fetchInited());&#10;            try {&#10;                const res = await fetch(&quot;http://httpbin.org/ip&quot;);&#10;                const json = await res.json();&#10;                dispatch(this.fetched(json));&#10;            } catch (e) {&#10;                const response = e.response || {};&#10;                const networkError = e.message === &quot;Network Error&quot;;&#10;                dispatch(this.fetchExceptionCaught(response, response.status, networkError));&#10;            }&#10;        }&#10;    }&#10;&#10;};&#10;" description="Generates redux actions boilerplate" toReformat="true" toShortenFQNames="true">
    <variable name="NAME" expression="" defaultValue="&quot;Foo&quot;" alwaysStopAt="true" />
    <variable name="ARGUMENT_NAME" expression="decapitalize(NAME)" defaultValue="" alwaysStopAt="false" />
    <variable name="FETCHED_ACTION_TYPE" expression="" defaultValue="&quot;\&quot;foo_fetched\&quot;&quot;" alwaysStopAt="true" />
    <variable name="FETCH_INIT_ACTION_TYPE" expression="" defaultValue="&quot;\&quot;foo_fetch_init\&quot;&quot;" alwaysStopAt="true" />
    <variable name="FETCH_ERROR_ACTION_TYPE" expression="" defaultValue="&quot;\&quot;foo_fetch_error\&quot;&quot;" alwaysStopAt="true" />
    <variable name="FETCH_RETURN_TYPE" expression="" defaultValue="&quot;ThunkAction&lt;void, any, any&gt;&quot;" alwaysStopAt="true" />
    <context>
      <option name="JAVA_SCRIPT" value="true" />
      <option name="TypeScript" value="true" />
    </context>
  </template>
  <template name="rdxreducer" value="import { AnyAction } from &quot;redux&quot;;&#10;&#10;export class $CLASS_NAME$State {&#10;    data = {};&#10;    error = {&#10;        response: null,&#10;        statusCode: null as number,&#10;        noNetworkError: false,&#10;    };&#10;    lastResOk = true;&#10;    isFetching = false;&#10;}&#10;&#10;const initial = new $CLASS_NAME$State()&#10;&#10;export const $REDUCER_NAME$Reducer = (state:$CLASS_NAME$State() = initial, action:AnyAction):$CLASS_NAME$State =&gt; {&#10;    switch (action.type) {&#10;&#10;        case $FETCH_INIT$:&#10;            return {&#10;                ...state, &#10;                isFetching: true,&#10;            };&#10;&#10;        case $FETCHED$:&#10;            return {&#10;                ...state, &#10;                isFetching: false, &#10;                lastResOk = true, &#10;                data: {...state.data, ...action.payload.reduce((a,b) =&gt; ({...a, [b.id]:b}), {})},&#10;                error: initial.error,&#10;            }&#10;            &#10;        case $HTTP_ERROR$:&#10;            return {&#10;                ...state, &#10;                isFetching: false, &#10;                lastResOk = false,&#10;                error: {&#10;                    response: action.payload.response,&#10;                    statusCode: action.payload.statusCode,&#10;                    noNetworkError: action.payload.noNetworkError,&#10;                }&#10;            }&#10;&#10;        default:&#10;            return state;&#10;    }&#10;};&#10;" description="Generates redux reducer boilerplate" toReformat="false" toShortenFQNames="true">
    <variable name="CLASS_NAME" expression="" defaultValue="&quot;Foo&quot;" alwaysStopAt="true" />
    <variable name="REDUCER_NAME" expression="decapitalize(CLASS_NAME)" defaultValue="" alwaysStopAt="false" />
    <variable name="FETCH_INIT" expression="" defaultValue="&quot;\&quot;fetch_inited\&quot;&quot;" alwaysStopAt="true" />
    <variable name="FETCHED" expression="" defaultValue="&quot;\&quot;fetched\&quot;&quot;" alwaysStopAt="true" />
    <variable name="HTTP_ERROR" expression="" defaultValue="&quot;\&quot;fetch_error\&quot;&quot;" alwaysStopAt="true" />
    <context>
      <option name="JAVA_SCRIPT" value="true" />
      <option name="TypeScript" value="true" />
    </context>
  </template>
</templateSet>